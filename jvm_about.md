##Java 运行时数据区（内存区域）

###堆
|项 | 描述|
|----|----|
|特点 | 线程共享，垃圾回收 |
|用途 | 存储程序运行产生的对象。包括静态数据和对象数据|
|区域划分 | 新生代区（eden、survivor0、survivor1）、老年代区、常量和静态变量区|
|可能异常 | 当执行多次垃圾回收后，仍然不能为新对象开辟空间，会报oom异常|
###虚拟机栈
|项 | 描述|
|----|----|
|特点 | 线程独享 |
|用途 | 栈帧的压栈与出栈，保存程序执行的路径|
|区域划分 | 程序栈（保存栈帧：局部变量表、操作数栈、动态连接和方法返回地址）、本地方法栈（java虚拟机调用本地方法，存储栈帧的区域）、程序计数器（记录程序状态位置，线程挂起记录位置，线程唤起读取位置继续执行）|
|可能异常 | 程序递归较深，栈帧一直入栈，超过栈的设置空间时会StackOverflow。如果栈空间动态分配，超过内存大小是，会oom|
###方法区（永久代、元空间）
|项 | 描述|
|----|----|
|用途 | jdk1.8之前，存储类相关信息、运行时常量、静态变量、jit编译后的代码。jdk1.8之后只保存类信息和jit编译后的代码|
|存储位置 | jdk1.8之前，存储在永久代（堆内）。jdk1.8之后，存储在元空间（直接内存）|
###运行时常量池（字符串常量池）
|项 | 描述|
|----|----|
|数据结构 | hash链表（hash快速算出存储位置。如有冲突，再链表存储）|
|特点 | 针对不同字符串，算出hashcode值，然后取模得到hash表位置。如果有冲突，再equals比较，如相等不存储。如不等，则在相同位置，再新建一个链表节点存储。（hashcode值相等，对象不一定相等。对象相等，hashcode值一定相等，因此如要重写，对象的hashcode和equals都要重写）|
|用途 | 保存字符串常量|
###直接内存
机器的直接物理内存，相对堆内存，性能更高。但是申请也更耗费性能。直接内存不受堆大小的限制，只受到本机内存大小限制。
###为什么堆内存要分年轻代和老年代？
大部分对象是朝生夕灭的，年轻代存储的对象大部分会被销毁。而对象被拷贝到老年代，一般不会被垃圾回收。针对年轻代，使用mark-copy算法，由于年轻代只有少许活下来，所有算法一般更高效。针对老年代，使用mark-sweep算法，一般只有少许的对象被清除。因此，从年轻代和老年代对象特点不同，区分出不同的区域，并且使用不同的算法，使垃圾回收更加高效。

##描述一个 Java 对象的生命周期

###解释一个对象的创建过程
1. 首先检查能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化。如果没有，则会先执行相应的类加载过程
2. 开始为新生的对象分配内存，当堆内存规整，将分界值指针往没用过的内存方向移动向应大小位置。当堆内存不规整，找到一块足够大的内存块分配给该对象即可
3. 将分配到的内存空间都进行默认值初始化
4. 对对象进行一些简单设置，如标记该对象是哪个类的实例，这个对象的hash码，该对象所处的年龄段这些信息被写在对象头中

###解释一个对象的内存分配
1. 对象堆内存位置分配
 - 判断eden区能否放下，能放下在eden区域开辟空间（大对象直接放在老年区）
 - eden区域放不下会触发ygc，ygc之后能放下则在eden/s0/s1开辟空间（s区域还有空间，则s1或者s0会来回拷贝对象，拷贝一次，对象年龄+1）
 - ygc依旧放不下，则放在老年代，能放下开辟空间，老年代放不下触发fgc
 - fgc触发后能放在，则在老年代开辟空间，多次fgc依旧无法分配空间，则oom
2. 对象本身的内存空间分配
 - 对象头，包括MarkWord（hashcode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，占用8byte）、类型指针（开启压缩占用4byte）、数据长度（数组对象才有，占用4byte）
 - 实例数据区域，对象声明的所有变量占用区域，包括引用类型占用4byte，基本数据类型占用对应类型空间
 - 对齐填充区域，在以上空间分配后自动补足，使对象空间占用是8byte的整数倍


###解释一个对象的销毁过程
1. 使用根可达算法，从线程栈、静态变量、常量、jit指针出发，计算路径
2. 在堆的年轻代里，把存在链引用的对象，拷贝到s0/s1区域，拷贝后，年轻代的对象被清楚。在老年代里，找出没有链路径的对象，进行清楚，并整理剩下的空间

###对象的 2 种访问方式是什么？
1. 通过句柄访问，在句柄池中找到引用对象指针
2. 直接通过对象指针访问

###为什么需要内存担保？
因为新生代采用复制收集算法，假如大量对象在ygc后仍然存活，s空间是比较小的，可能放不下eden拷贝的对象。这时就需要老年代进行分配担保，把s无法容纳的对象放到老年代，确保能容纳下足够的对象。因此会对比老年代空间大小和年轻代总对象大小，或者取之前每次垃圾回收后晋升到老年代对象大小的平均值作为参考。

##垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

####垃圾收集算法
|算法 | 描述|  优缺点 | 适用区域|
|----|----|---| --- |
|mark-sweep | 对需要回收的对象进行标记，标记完成后统一清除| 缺点：大多数对象是朝生夕灭的，一般需要标记的对象比较多，所以效率不高。并且会产生大量的内存碎片| 与coping结合，应用与年轻代|
|coping | 对存活的对象进行拷贝，拷贝后原有区域清空| 优点：内存空间都是连续的。<br> 缺点：对象拷贝，需要更大的空间 |与mark-sweep结合，应用与年轻代|
|mark-compact | 对需要回收的对象进行标记，标记完成后统一清除，然后对空间重排，保证占用空间连续 | 优点：内存空间都是连续的 <br> 缺点：效率不高| 老年代|

####垃圾收集器
|收集器 | 年轻代收集|  老年代收集 | 特点|
|----|----|---|---|
|Serial收集器 |单线程清理。暂停所有线程，采取复制算法。 | 单线程清理。暂停所有线程，标记整理算法 |适应单个cpu，没有线程交互开销 |
|ParNew收集器 |多线程清理。暂停所有线程，采取复制算法。 | 单线程清理。暂停所有线程，标记整理算法 |Serial收集器的多线程版本 |
|ParallelScavenge收集器 | 多线程清理。暂停所有线程，采取复制算法。| 单线程清理。暂停所有线程，标记整理算法|吞吐量优先 |
|ParallelOld收集器|无 | 多线程清理。暂停所有线程，标记整理算法| 吞吐量优先 |
|CMS收集器| 1. 标记出GCRoots能直接关联到的对象(stw) <br> 2.从GC Roots的直接关联对象遍历整个对象图 <br> 3.修正并发标记期间，因用户程序继续运作产生的新的对象记录 <br> 4.清理删除掉标记阶段判断的已经死亡的对象，释放内存空间 | 同年轻代 | 遍历对象路径的耗时操作不会stw，因此延迟低 |
|G1收集器| 1，2，3同cms<br> 4.对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划| 同年轻代| 能让使用者明确指定消耗在垃圾收集上的时间 |
